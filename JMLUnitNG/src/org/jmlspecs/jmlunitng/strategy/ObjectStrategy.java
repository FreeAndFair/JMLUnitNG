/*
 * JMLUnitNG 
 * Copyright (C) 2010
 */

package org.jmlspecs.jmlunitng.strategy;

import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

import org.jmlspecs.jmlunitng.iterator.InstantiationIterator;
import org.jmlspecs.jmlunitng.iterator.MultiIterator;
import org.jmlspecs.jmlunitng.iterator.NonNullMultiIterator;
import org.jmlspecs.jmlunitng.iterator.ObjectArrayIterator;
import org.jmlspecs.jmlunitng.iterator.RepeatedAccessIterator;

/**
 * The strategy for all non-primitive types. For Enums, it always
 * provides all values of the enum unless the default values are
 * overridden. For other types of object, it attempts to find
 * test data generators for the default values.
 * 
 * @author Jonathan Hogins
 * @author Daniel M. Zimmerman
 * @version November 2010
 */
public abstract class ObjectStrategy implements Strategy {  
  /**
   * The class for which this strategy was made.
   */
  private final Class<?> my_class;
  
  /**
   * Should we use reflective data generation?
   */
  private final boolean my_reflective;
  
  /**
   * The test data generators found for this object strategy to use.
   */
  private List<Class<? extends ObjectStrategy>> my_generators;

  /**
   * The classes that are generated by the test data generators.
   */
  private List<Class<?>> my_generator_classes;
  
  /**
   * The classes for which we should use the default constructors
   * since no test data classes were found.
   */
  private List<Class<?>> my_non_generator_classes;
  
  /**
   * The enum constants for the given class, if it is an enum type.
   */
  private Object[] my_enum_constants; 
  
  /**
   * Creates a new ObjectStrategy for the given class. If the_reflective flag
   * is true, then default values will be generated reflectively using the 
   * data generator for the class, if it exists, or (in the case of enums) 
   * will be all enum values. If the_reflective flag is false, there will 
   * be no default values.
   * 
   * @param the_class The class to generate the strategy for.
   * @param the_reflective The reflective flag.
   */
  public ObjectStrategy(final Class<?> the_class, final boolean the_reflective) {
    my_class = the_class;
    my_reflective = the_reflective;
    my_generators = new LinkedList<Class<? extends ObjectStrategy>>();
    my_generator_classes = new LinkedList<Class<?>>();
    my_non_generator_classes = new LinkedList<Class<?>>();
    my_enum_constants = null;
    
    if (the_class.getEnumConstants() == null) {
      // it is not an enum
      addDataClass(the_class);
    } else {
      // it is an enum
      my_enum_constants = the_class.getEnumConstants();
    }
  }

  /**
   * Creates a new ObjectStrategy for the given class. Default values will be
   * generated reflectively by the test data class for the_class if present;
   * for enumerations, all enum constants will be used.
   * 
   * @param the_class The class for which to use test data from.
   */
  public ObjectStrategy(final Class<?> the_class) {
    this(the_class, true);
  }
  
  /**
   * A default empty iterator, may be overridden by child classes.
   * @return An empty iterator.
   */
  public RepeatedAccessIterator<?> getLocalValues() {
    return new ObjectArrayIterator<Object>
    ((Object[]) Array.newInstance(my_class, 0));
  }
  
  /**
   * A default empty iterator, may be overridden by child classes.
   * @return An empty iterator.
   */
  public RepeatedAccessIterator<?> getClassValues() {
    return new ObjectArrayIterator<Object>
    ((Object[]) Array.newInstance(my_class, 0));
  }

  /**
   * A default empty iterator, may be overridden by child classes.
   * @return An empty iterator.
   */
  public RepeatedAccessIterator<?> getPackageValues() {
    return new ObjectArrayIterator<Object>
    ((Object[]) Array.newInstance(my_class, 0));
  }
  
  /**
   * Returns an iterator over the values defined in the class' test data
   * definition if it exists. Otherwise, returns an iterator over
   * DEFAULT_VALUES.
   * 
   * @return An Iterator over default values.
   */
  @SuppressWarnings({"unchecked", "rawtypes"})
  public RepeatedAccessIterator<?> getDefaultValues() {
    final List<RepeatedAccessIterator<?>> result_list = 
      new LinkedList<RepeatedAccessIterator<?>>();
    result_list.add(new ObjectArrayIterator<Object>(new Object[] { null }));
    if (my_reflective && my_enum_constants == null && !my_generators.isEmpty()) {
      // try to return data generated using reflection
      final List<RepeatedAccessIterator<?>> iterators = 
        new LinkedList<RepeatedAccessIterator<?>>();
      for (Class<? extends ObjectStrategy> c : my_generators) {
        try {
          iterators.add(c.newInstance().iterator());
        } catch (InstantiationException e) {
          e.printStackTrace();
        } catch (IllegalAccessException e) {
          e.printStackTrace();
        }
      }
      for (Class<?> c : my_non_generator_classes) {
        // add the default constructor for each non-generator class
        iterators.add
          (new InstantiationIterator(c, new Class<?>[0], 
                                     new ObjectArrayIterator<Object[]>(new Object[][]{{}})));
      }
      result_list.add(new NonNullMultiIterator(iterators));
    } else if (!my_reflective && my_enum_constants == null) {
      // no reflection, but we can still use default constructors
      final List<RepeatedAccessIterator<?>> iterators = 
        new LinkedList<RepeatedAccessIterator<?>>();
      for (Class<?> c : my_generator_classes) {
        // add the default constructor for each non-generator class
        iterators.add
          (new InstantiationIterator(c, new Class<?>[0], 
                                     new ObjectArrayIterator<Object[]>(new Object[][]{{}})));        
      }
      for (Class<?> c : my_non_generator_classes) {
        // add the default constructor for each non-generator class
        iterators.add
          (new InstantiationIterator(c, new Class<?>[0], 
                                     new ObjectArrayIterator<Object[]>(new Object[][]{{}})));        
      }
      result_list.add(new NonNullMultiIterator(iterators));
    } else if (my_enum_constants != null) { 
      // return the enum constants
      result_list.add(new ObjectArrayIterator<Object>(my_enum_constants));
    }
    
    return new MultiIterator(result_list);
  }
  
  /**
   * Returns a RepeatedAccessIterator over all values in the order: local-scope
   * values, class-scope values, package-scope values, default values.
   * 
   * @return What are all your values?
   */
  @SuppressWarnings({"unchecked", "rawtypes"})
  public RepeatedAccessIterator<?> iterator() {
    final List<RepeatedAccessIterator<?>> iterators = new ArrayList<RepeatedAccessIterator<?>>(3);
    iterators.add(getLocalValues());
    iterators.add(getClassValues());
    iterators.add(getPackageValues());
    iterators.add(getDefaultValues());
    return new MultiIterator(iterators);
  }
  
  /**
   * Adds a data class to be used by this iterator if reflection
   * is turned on.
   * 
   * @param the_class The new data class.
   */
  @SuppressWarnings("unchecked")
  public final void addDataClass(final Class<?> the_class) {
    if (the_class.getEnumConstants() == null) {
      // it's not an enum, so we can add it
      try {
        final Class<?> generator_class = 
          Class.forName(the_class.getName() + "_JML_Data.InstanceStrategy");
        if (ObjectStrategy.class.isAssignableFrom(generator_class)) {
          my_generators.add((Class<? extends ObjectStrategy>) generator_class);
          my_generator_classes.add(the_class);
        } else {
          my_non_generator_classes.add(the_class);
        }
      } catch (ClassNotFoundException e) {
        my_non_generator_classes.add(the_class);
      }
    }
  }
}
