/*
 * JMLUnitNG 
 * Copyright (C) 2010
 */

package org.jmlspecs.jmlunitng.strategy;

import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

import org.jmlspecs.jmlunitng.iterator.InstantiationIterator;
import org.jmlspecs.jmlunitng.iterator.MultiIterator;
import org.jmlspecs.jmlunitng.iterator.NonNullMultiIterator;
import org.jmlspecs.jmlunitng.iterator.ObjectArrayIterator;
import org.jmlspecs.jmlunitng.iterator.RepeatedAccessIterator;

/**
 * The strategy for all array types. It attempts to generate arrays
 * of lengths up to the specified maximum, using strategies for 
 * the array component type.
 * 
 * @author Daniel M. Zimmerman
 * @version January 2011
 */
public abstract class ArrayStrategy implements Strategy {  
  /**
   * The class for which this strategy was made.
   */
  private final Class<?> my_class;
  
  // TODO consider making the following 3 collections into Sets
  /**
   * The test data generators found for this array strategy to use.
   */
  private final List<Class<? extends Strategy>> my_generators;

  /**
   * The classes that are generated by the test data generators.
   */
  private final List<Class<?>> my_generator_classes;
  
  /**
   * The classes for which we should use the default constructors
   * since no test data classes were found.
   */
  private final List<Class<?>> my_non_generator_classes;

  /**
   * The maximum array size to generate.
   */
  /**
   * Creates a new ArrayStrategy for the given class. Default values will
   * be generated by using the strategy for the array's component type 
   * (and any subtypes specified post-construction). 
   *   
   * @param the_class The array class for which to generate test data.
   * @exception IllegalArgumentException if the_class is not an array type.
   */
  public ArrayStrategy(final Class<?> the_class) {
    if (!the_class.isArray()) {
      throw new IllegalArgumentException
      ("Cannot create ArrayStrategy for type " + the_class);
    }
    my_class = the_class;
    my_generators = new ArrayList<Class<? extends Strategy>>();
    my_generator_classes = new ArrayList<Class<?>>();
    my_non_generator_classes = new ArrayList<Class<?>>();
    
    // add the generator for the array element type as a data class
    addDataClass(my_class.getComponentType());
  }
  
  /**
   * A default empty iterator, may be overridden by child classes.
   * @return An empty iterator.
   */
  public RepeatedAccessIterator<?> getLocalValues() {
    return new ObjectArrayIterator<Object>
    ((Object[]) Array.newInstance(my_class, 0));
  }
  
  /**
   * A default empty iterator, may be overridden by child classes.
   * @return An empty iterator.
   */
  public RepeatedAccessIterator<?> getClassValues() {
    return new ObjectArrayIterator<Object>
    ((Object[]) Array.newInstance(my_class, 0));
  }

  /**
   * A default empty iterator, may be overridden by child classes.
   * @return An empty iterator.
   */
  public RepeatedAccessIterator<?> getPackageValues() {
    return new ObjectArrayIterator<Object>
    ((Object[]) Array.newInstance(my_class, 0));
  }
  
  /**
   * Returns an iterator over the values defined in the class' test data
   * definition if it exists. Otherwise, returns an iterator over
   * DEFAULT_VALUES.
   * 
   * @return An Iterator over default values.
   */
  @SuppressWarnings({"unchecked", "rawtypes"})
  public RepeatedAccessIterator<?> getDefaultValues() {
    return null;
  }
  
  
  /**
   * Adds a data class to be used by this strategy.
   * 
   * @param the_class The new data class.
   * @exception ClassCastException if the new data class cannot
   *  be cast to the component type of this array strategy.
   */
  @SuppressWarnings("unchecked")
  public final void addDataClass(final Class<?> the_class) {
    if (!my_class.getComponentType().isAssignableFrom(the_class)) {
      throw new ClassCastException
      ("Cannot add " + the_class + " as a data class to array " +
       "strategy for " + my_class);
    }
    
    if (!my_generator_classes.contains(the_class) &&
        !my_non_generator_classes.contains(the_class)) { 
      // it's not already added, so we can add it
      Class<?> generator_class = findStrategyClass(the_class); 
      if (generator_class != null &&
          ObjectStrategy.class.isAssignableFrom(generator_class)) {
        my_generators.add((Class<? extends ObjectStrategy>) generator_class);
        my_generator_classes.add(the_class);
      } else {
        my_non_generator_classes.add(the_class);
      }
    }
  }
  
  /**
   * Clears the list of data classes to be used by this strategy; note that
   * it always uses the data class for its own component type, so that data
   * class is never cleared.
   */
  public final void clearDataClasses() {
    my_generators.clear();
    my_generator_classes.clear();
    my_non_generator_classes.clear();
    
    addDataClass(my_class.getComponentType());
  }
  
  /**
   * Finds the appropriate strategy class to use for the specified class.
   * 
   * @param the_class The class to find a strategy class for.
   * @return the strategy class, or null if no strategy class can be loaded.
   */
  private final Class<?> findStrategyClass(final Class<?> the_class) {
    Class<?> result = null;
    final String class_name = the_class.getName();
    
    if (the_class.getPackage() == null) {
      result = loadClass(class_name + "_InstanceStrategy");
    } else {
      result = loadClass(class_name + "_JML_Data.InstanceStrategy");
    }
    
    if (result == null) {
      final String formatted_name = formatClassName(class_name);
      // no instance strategy, try to find a class strategy in our "package"
      if (my_class.getPackage() == null) {
        // the first bit of our name, before the first underscore, is our prefix
        final String prefix = 
          my_class.getName().substring(0, my_class.getName().indexOf('_'));
        // a class strategy name looks like "prefix_ClassStrategy_formattedclassname"
        result = 
          loadClass(prefix + "_ClassStrategy_" + formatted_name);
      } else {
        // a class strategy name, in our package, looks like 
        // "ClassStrategy_formattedclassname"
        final String pkg_name = 
          my_class.getName().substring(0, my_class.getName().lastIndexOf('.'));
        result = loadClass(pkg_name + ".ClassStrategy_" + formatted_name);
      }
    }

    if (result == null) {
      final String formatted_name = formatClassName(class_name);
      // no instance or class strategy, try to find a package strategy
      if (my_class.getPackage() == null) {
        // a package strategy name looks like "PackageStrategy_formattedclassname"
        result = loadClass("PackageStrategy_" + formatted_name);
      } else {
        // we need to look in our parent package
        final String pkg_name = 
          my_class.getName().substring(0, my_class.getName().lastIndexOf('.'));
        final String parent_pkg_name = 
          pkg_name.substring(0, pkg_name.lastIndexOf('.'));
        result = loadClass(parent_pkg_name + ".PackageStrategy_" + formatted_name);
      }
    }
    
    // and that's it; if we didn't find anything, that's too bad, we return null
    return result;
  }
  
  /**
   * Attempts to load the specified class.
   * 
   * @param the_name The name of the class.
   * @return the class, or null if it does not exist.
   */
  private final Class<?> loadClass(final String the_name) {
    try {
      return Class.forName(the_name);
    } catch (ClassNotFoundException e) {
      return null;
    }
  }
  
  /**
   * Formats the name of a class, for use in locating strategies.
   * 
   * @param the_name The name to format.
   * @return The formatted name.
   */
  private final String formatClassName(final String the_name) {
    final StringBuilder formatted = new StringBuilder(the_name.replace('.', '_'));
    if (the_name.contains("[]")) {
      final int array_dimension = 
        the_name.substring(the_name.indexOf("[]"), the_name.length()).length() / 2;
      formatted.delete(formatted.indexOf("[]"), formatted.length());
      formatted.append(array_dimension + "DArray");
    } 
    return formatted.toString();
  }
}
