/*
 * OpenJMLUnit
 * 
 * @author "Daniel M. Zimmerman (dmz@acm.org)"
 * 
 * @module "OpenJML"
 * 
 * @creation_date "March 2010"
 * 
 * @last_updated_date "March 2010"
 * 
 * @keywords "unit testing", "JML"
 */

package org.jmlspecs.jmlunitng.iterator;

import java.util.Iterator;

import org.jmlspecs.jmlunitng.strategy.BasicStrategy;

/**
 * A repeated access iterator that generates arrays of objects by reflectively
 * instantiating iterator classes that contain test parameter data.
 * 
 * @author Daniel M. Zimmerman
 * @author Jonathan Hogins
 * @version March 2010
 */
public class ParameterArrayIterator implements RepeatedAccessIterator<Object[]>, Iterator<Object[]> {
  /**
   * The list of iterator generation methods
   */
  private final Class<? extends BasicStrategy>[] my_strategy_classes;
  
  /**
   * The current Strategies.
   */
  // @ invariant my_strategies.length == my_strategy_classes.length;
  private RepeatedAccessIterator<?>[] my_strategies;

  /**
   * The current element.
   */
  // @ invariant my_element.length == my_strategies.length;
  private Object[] my_element;
  
  /**
   * Is this iterator finished?
   */
  private boolean my_is_finished;
  
  /**
   * A wrapper for this class that enables its use as a java.util.Iterator.
   */
  private final IteratorWrapper<Object[]> my_iterator_wrapper;

  /**
   * Creates a new ObjectArrayIterator that iterates over all combinations of objects
   * in the given Strategy classes.
   * 
   * @param the_strategy_classes The strategies to iterate over.
   * @throws IllegalArgumentException An InstantiationException or IllegalAccessException was caught
   * when calling the nullary constructors of the_strategy_classes.
   */
  /*@ requires (\forall int i; i >= 0 && i < the_strategy_classes.length; 
    @		the_strategy_classes[i].newInstance().iterator().hasElement());
    @ ensures my_strategies.length == the_strategy_classes.length &&
    @		my_strategy_classes.length == the_strategy_classes.length &&
    @		(\forall int i; i >= 0 && i < my_strategies.length; my_strategies[i].hasElement());
   */
  public ParameterArrayIterator(final Class<? extends BasicStrategy>... the_strategy_classes) {
  	my_strategy_classes = the_strategy_classes;
  	my_strategies = new RepeatedAccessIterator<?>[the_strategy_classes.length];
  	my_is_finished = the_strategy_classes.length == 0;
  	my_element = new Object[my_strategies.length];
  	for (int i = 0; i < my_strategies.length; i++) {
  		try {
				my_strategies[i] = the_strategy_classes[i].newInstance().iterator();
				if (my_strategies[i].hasElement()) {
				  my_element[i] = my_strategies[i].element();
				} else {
				  my_element[i] = null;
				}
			} catch (InstantiationException e) {
				throw new IllegalArgumentException(e);
			} catch (IllegalAccessException e) {
				throw new IllegalArgumentException(e);
			}
  	}
    my_iterator_wrapper = new IteratorWrapper<Object[]>(this);
	}

  public void advance() {
  	internalAdvance();
  }

  /**
   * Returns an ArrayList<Object>, where each object is generated by using an
   * iterator provided by the iterator generation method in the corresponding
   * position of the list.
   */
  public Object[] element() {
    return my_element;
  }

  /**
   * Returns true if there are more elements in this iterator. False if not.
   * @return True if there are more elements in this iterator. False if not.
   */
  public boolean hasElement() {
  	return !my_is_finished;
  }
  
  /**
   * Helper method. Advances the iterator. Seperate from advance() to allow a call in the constructor.
   */
  /*@ requires !my_is_finished;
    @ ensures (\forall Integer i; i >= 0 && i < my_strategies.length; my_strategies[i].hasElement()) ||
    @						my_is_finished;
   */
  private void internalAdvance() {
  	int p = 0;
		try {
			boolean continue_loop = true;
			do {
		  //ensure each iterator is at a valid element
				my_strategies[p].advance();
				if (my_strategies[p].hasElement()) {
					continue_loop = false;
				} else {
					my_strategies[p] = (RepeatedAccessIterator<?>) my_strategy_classes[p].newInstance().iterator();
		      p++;
				}
			} while (p < my_strategies.length && continue_loop);
			my_element = new Object[my_strategies.length];
			for (int i = 0; i < my_strategies.length; i++) {
				if (my_strategies[i].hasElement()) {
				  my_element[i] = my_strategies[i].element();
				} else {
				  my_element[i] = null;
				}
			}
			//we've reset the last iterator, meaning we are finished.
			my_is_finished = p == my_strategies.length;
		} catch (InstantiationException e) {
			// Already checked for exceptions in constructor. Should never be hit
			System.err.println(e);
		} catch (IllegalAccessException e) {
			System.err.println(e);
		}
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public boolean hasNext() {
    return my_iterator_wrapper.hasNext();
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public Object[] next() {
    return my_iterator_wrapper.next();
  }

  /**
   * Not implemented.
   * @throws UnsupportedOperationException Always thrown.
   */
  //@ signals (UnsupportedOperationException) true;
  @Override
  public void remove() throws UnsupportedOperationException {
    throw new UnsupportedOperationException();
  }

  // @constraint "The sequence of elements returned consists of arrays of
  // objects,
  // where each object is generated by using an iterator provided by
  // the iterator generation method in the corresponding position of
  // the list."

}
