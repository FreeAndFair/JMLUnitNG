group test_class_java : shared_java;

main(date, class, methods, packageName, packaged) ::= <<
/*
 * Test Oracle Class for <class.fullyQualifiedName>
 * For Use With JML4 RAC
 * Generated by JMLUnitNG on <date>
 */
 
<if (packaged)>
package <packageName>;
<endif>

import java.io.PrintWriter;

import org.jmlspecs.openjmlunit.testng.BasicTestListener;
import org.jmlspecs.openjmlunit.testng.PreconditionSkipException;
import org.testng.TestException;
import org.testng.TestNG;
import org.testng.annotations.Test;

import org.jmlspecs.jml4.rac.runtime.JMLEntryPreconditionError;
import org.jmlspecs.jml4.rac.runtime.JMLEvaluationError;
import org.jmlspecs.jml4.rac.runtime.JMLAssertionError;

<if (packaged)>
import <packageName>.<test class name goes here>_jml_data
<else>
import <test class name goes here>_data
<endif>

/**
 * Test oracles generated by JMLUnitNG for JML4 RAC of class
 * <class.fullyQualifiedName>.
 * 
 * @author JMLUnitNG
 * @version <date>
 */
 
public class <testClassName(class)> {

  /** Constructs the class object. */
  public <testClassName(class)>() {
  }
  
  /** This is the main method to run the test. */
  public static void main(String[] args) {
    final TestNG testng_runner = new TestNG();
    final Class\<?\>[] classes = {<testClassName(class)>.class};
    final BasicTestListener listener = new BasicTestListener(new PrintWriter(System.out));
    testng_runner.setTestClasses(classes);
    testng_runner.addListener(listener);
    testng_runner.run();
  }
  
  /** Checks to see if RAC is enabled. */
  @Test
  public void test_racEnabled() {
    Assert.assertTrue
    (JMLChecker.isRACCompiled
      (<class.fullyQualifiedName>.class),
     "JMLUnitNG tests can only run on RAC-compiled code.");
  } 
  
  <methods:methodTest(); separator="\n">
  <methods:methodProvider(); separator="\n">
  <if(!class.abstract)>
  <classOnlyDataProvider()>
  <endif>
}
>>

methodTest(method) ::= <<
/**
 * This method is a test for <if(method.constructor)>a constructor<else>method <method.name><endif> from the class to be
 * tested.<if(!method.constructor)>
 
 * @param the_test_object The <method.declaringClass.shortName> to call the test method on.
<endif>

<method.parameterTypes:varJavaDocLine(); separator="\n">
 */
<if(method.parameterTypes)>
@Test(dependsOnMethods = { "test_racEnabled" }, dataProvider = "<dataProviderName()>")

<else>
<if(!method.constructor)>
@Test(dependsOnMethods = { "test_racEnabled" }, dataProvider = "<classOnlyDataProviderName()>")

<else>
@Test(dependsOnMethods = { "test_racEnabled" })

<endif>
<endif>
public void <testName()>(<if(!method.constructor)>final <method.declaringClass.fullyQualifiedName> the_test_object<if(method.parameterTypes)>, <endif><endif><varDecList(method.parameterTypes)>) {
  <if(!method.constructor)>
  if (the_test_object == null) {
    throw new PreconditionSkipException("could not construct an object");
  }
  <endif>
  try {
    <if(method.constructor)>
    new <method.name>(<varNameList(method.parameterTypes)>);
    <else>
    the_test_object.<method.name>(<varNameList(method.parameterTypes)>);
    <endif>
  }
  catch (final JMLEntryPreconditionError the_exp) {
    // meaningless test
    throw new PreconditionSkipException(the_exp.getMessage());
  }
  catch (final JMLEvaluationError the_exp) {
    if (the_exp.getCause() instanceof JMLEntryPreconditionError) {
      // meaningless test
      throw new PreconditionSkipException(the_exp.getCause().getMessage());
    } else {
      // failed test
      throw new TestException(the_exp.getCause().getMessage());
    }
  }
  catch (final JMLAssertionError the_exp) {
    // test failure
    throw new TestException(the_exp.getMessage());
  }
  catch (final Exception the_exp) {
    // test failure for some reason other than assertion violation
    throw new TestException(the_exp.getMessage());
  }
}

>>

methodProvider(method) ::= <<
<if(method.parameterTypes)>/**
 * Data provider for <if(method.constructor)>constructor<else>method<endif> <method>.
 * @return An iterator over strategies to use for parameter generation.
 */
@SuppressWarnings({"unchecked"})
@DataProvider(name = "<dataProviderName()>")
public static Iterator\<Object[]\> <dataProviderName()>() {
  return new ParameterArrayIterator(<if(!method.constructor)><classStrategyName()>.class, <endif><method.parameterTypes:{<strategyName(method=method, param=it)>.class}; wrap="\n    ", separator=", ">);
}
<endif>

>>

classOnlyDataProvider() ::= <<
/**
 * Data provider for methods with no parameters.
 * @return An iterator over the main class strategy.
 */
@SuppressWarnings({"unchecked"})
@DataProvider(name = "<classOnlyDataProviderName()>")
public static Iterator\<Object[]\> <classOnlyDataProviderName()>() {
  return new ParameterArrayIterator(<classStrategyName()>.class);
}

>>