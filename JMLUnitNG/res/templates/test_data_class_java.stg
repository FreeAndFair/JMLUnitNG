group test_data_class_java : shared_java;

main(date, class, methods, types, packageName, packaged) ::= <<
/*
 * Test Data Class for <class.fullyQualifiedName>
 * Generated by JMLUnitNG on <date>
 */
 
<if (packaged)>
package <packageName>;
<endif>

import java.util.LinkedList;
import java.util.List;
import java.util.Iterator;

import org.jmlspecs.jmlunitng.iterator.*;
import org.jmlspecs.jmlunitng.strategy.*;

import org.testng.annotations.DataProvider;

<if (packaged)>
import <class.fullyQualifiedName>;
<endif>

/**
 * Data provider class generated by JMLUnitNG for class
 * <class.fullyQualifiedName>.
 * 
 * @author JMLUnitNG
 * @version <date>
 */
public class <dataClassName(class)> {
  <types:typeData(); separator="\n">
  <methods:methodData(); separator="\n">
  //---------------------------------------------------------------
  //End of user definitions
  //---------------------------------------------------------------
  /** Constructs the class object. */
  protected <dataClassName(class)>() {
  }
  <methods:methodProvider()>
  
  <if(!class.abstract)>
  <classOnlyDataProvider()>
  <classStrategy()>
  <endif>
}
>>

typeData() ::= <<
/**
 * For user definition. Supplies values of type <it.fullyQualifiedName> 
 * to be tested on each matching parameter.
 */
public static abstract class <globalStrategyName(typeName=it.formattedName)> extends <baseStrategyMap.(it.fullyQualifiedName)> {
  public RepeatedAccessIterator\<?\> getGlobalValues() {
    return new ObjectArrayIterator\<<typeTransMap.(it.fullyQualifiedName)>\>(new <typeTransMap.(it.fullyQualifiedName)>[] 
    { /* add global <it.fullyQualifiedName> values here */ });
  }
  <if(!it.primitive)>
  
  public <globalStrategyName(typeName=it.formattedName)>() {
    super(<it.fullyQualifiedName>.class);
  }
  <endif>
}

>>

methodData(method) ::= <<
<it.parameterTypes:paramData(the_method=method)>
>>

paramData(the_method) ::= <<
/**
 * For user definition. Supplies test values for:
 * Variable: <it.fullyQualifiedName> <it:varName()> 
 * Method: <the_method>
 */
public static class <strategyName(method=the_method, param=it)> extends <globalStrategyName(typeName=it.formattedName)> {
  public RepeatedAccessIterator\<?\> getCustomValues() {
  	return new ObjectArrayIterator\<<type(typeInfo=it)>\>(new <type(typeInfo=it)>[] 
  	{ /* add custom <it.fullyQualifiedName> values here */ });
  }
}

>>

methodProvider(method) ::= <<
<if(method.parameterTypes)>/**
 * Data provider for <if(method.constructor)>constructor<else>method<endif> <method>.
 * @return An iterator over strategies to use for parameter generation.
 */
@SuppressWarnings({"unchecked"})
@DataProvider(name = "<dataProviderName()>")
public static Iterator\<Object[]\> <dataProviderName()>() {
  return new ParameterArrayIterator(<if(!method.constructor)><classStrategyName()>.class, <endif><method.parameterTypes:{<strategyName(method=method, param=it)>.class}; wrap="\n    ", separator=", ">);
}
<endif>

>>

classOnlyDataProvider() ::= <<
/**
 * Data provider for methods with no parameters.
 * @return An iterator over the main class strategy.
 */
@SuppressWarnings({"unchecked"})
@DataProvider(name = "<classOnlyDataProviderName()>")
public static Iterator\<Object[]\> <classOnlyDataProviderName()>() {
  return new ParameterArrayIterator(<classStrategyName()>.class);
}

>>

classStrategy() ::= <<
/**
 * Utilizes constructor parameter data to define valid instances of <class.fullyQualifiedName> 
 * on which to call methods under test.
 */
public static class <classStrategyName()> extends ObjectStrategy {
  public RepeatedAccessIterator\<<class.shortName>\> getGlobalValues() {
    final List\<RepeatedAccessIterator\<<class.shortName>\>\> iters = 
      new LinkedList\<RepeatedAccessIterator\<<class.shortName>\>\>();
    
    // always add an instantiation iterator for the empty constructor
    iters.add(new InstantiationIterator\<<class.shortName>\>
      (<class.shortName>.class, new Class\<?\>[0], 
       new ObjectArrayIterator\<Object[]\>(new Object[][]{{}})));
    
    <methods:{<classStrategyConstructorData(method=it)>}>
    return new NonNullMultiIterator\<<class.shortName>\>(iters);
  }
  public RepeatedAccessIterator\<<class.shortName>\> getCustomValues() {
    return new ObjectArrayIterator\<<class.shortName>\>(new <class.shortName>[0]);
  }
  public RepeatedAccessIterator\<<class.shortName>\> getDefaultValues() {
    return new ObjectArrayIterator\<<class.shortName>\>(new <class.shortName>[0]);
  }
  public <classStrategyName()>() {
    super(<class.shortName>.class);
  }
}

>>

classStrategyConstructorData(method) ::= <<
<if(method.constructor)>
<if(method.parameterTypes)>
// parameters for method <method>
iters.add(new InstantiationIterator\<<class.shortName>\>
  (<class.shortName>.class, new Class\<?\>[]{<paramClasses()>},
   new IteratorAdapter\<Object[]\>(<dataProviderName()>())));

<endif>
<endif>
>>

paramClasses() ::= "<method.parameterTypes:{<it:rawtype()>.class}; wrap=\"\n      \", separator=\", \">"
strategyName(method, param) ::= "<param.parameterName>_<method.uniqueName>_Strategy"
classStrategyName() ::= "ClassObjectStrategy"
globalStrategyName(typeName) ::= "<it.formattedName>_GlobalStrategy"