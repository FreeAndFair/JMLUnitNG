/*
 * OpenJMLUnit
 * 
 * @author "Daniel M. Zimmerman (dmz@acm.org)"
 * 
 * @module "OpenJML"
 * 
 * @creation_date "March 2010"
 * 
 * @last_updated_date "March 2010"
 * 
 * @keywords "unit testing", "JML"
 */

package org.jmlspecs.openjmlunit.iterator;

import java.util.Iterator;

import org.jmlspecs.openjmlunit.strategy.BasicStrategy;

/**
 * A repeated access iterator that generates arrays of objects by reflectively
 * instantiating iterator classes that contain test parameter data.
 * 
 * @author Daniel M. Zimmerman
 * @author Jonathan Hogins
 * @version March 2010
 */
public class ObjectArrayIterator implements RepeatedAccessIterator<Object[]>, Iterator<Object[]> {
  /**
   * The list of iterator generation methods
   */
  private final Class<? extends BasicStrategy>[] my_strategy_classes;
  
  /**
   * The current Strategies.
   */
  // @ invariant my_strategies.length == my_strategy_classes.length;
  private RepeatedAccessIterator<?>[] my_strategies;

  /**
   * The current element.
   */
  // @ invariant my_element.length == my_strategies.length;
  private Object[] my_element;
  
  /**
   * Is this iterator finished?
   */
  private boolean my_is_finished;
  
  /**
   * A wrapper for this class that enables its use as a java.util.Iterator.
   */
  private IteratorWrapper<Object[]> my_iterator_wrapper;

  /**
   * Creates a new ObjectArrayIterator that iterates over all combinations of objects
   * in the given Strategy classes.
   * 
   * @param the_strategy_classes The strategies to iterate over.
   * @throws IllegalArgumentException An InstantiationException or IllegalAccessException was caught
   * when calling the nullary constructors of the_strategy_classes.
   */
  /*@ requires (\foreach int i; i >= 0 && i < the_strategy_classes.length; 
    @		the_strategy_classes[i].newInstance().iterator().hasNext());
    @ ensures my_strategies.length == the_strategy_classes.length &&
    @		my_strategy_classes.length == the_strategy_classes.length &&
    @		(\foreach int i; i >= 0 && i < my_strategies.length; my_strategies[i].hasNext());
   */
  public ObjectArrayIterator(Class<? extends BasicStrategy>... the_strategy_classes) {
  	my_strategy_classes = the_strategy_classes;
  	my_strategies = new RepeatedAccessIterator<?>[the_strategy_classes.length];
  	my_is_finished = false;
  	for (int i = 0; i < my_strategies.length; i++) {
  		try {
				my_strategies[i] = the_strategy_classes[i].newInstance().iterator();
			} catch (InstantiationException e) {
				throw new IllegalArgumentException(e);
			} catch (IllegalAccessException e) {
				throw new IllegalArgumentException(e);
			}
  	}
  	internalAdvance();
    my_iterator_wrapper = new IteratorWrapper<Object[]>(this);
	}

  public void advance() {
  	internalAdvance();
  }

  /**
   * Returns an ArrayList<Object>, where each object is generated by using an
   * iterator provided by the iterator generation method in the corresponding
   * position of the list.
   */
  public Object[] element() {
    return my_element;
  }

  /**
   * Returns true if there are more elements in this iterator. False if not.
   * @return True if there are more elements in this iterator. False if not.
   */
  public boolean hasMoreElements() {
  	return my_is_finished;
  }
  
  /**
   * Helper method. Advances the iterator. Seperate from advance() to allow a call in the constructor.
   */
  //@ requires !my_is_finished;
  private void internalAdvance() {
  	int p = 0;
		try {
			my_element = new Object[my_strategies.length];
			for (int i = 0; i < my_strategies.length; i++) {
				my_element[i] = my_strategies[i].element();
			}
			while (p < my_strategies.length && !my_strategies[p].hasMoreElements()) {
				my_strategies[p] = (RepeatedAccessIterator<?>) my_strategy_classes[p].newInstance();
				p++;
			}
			if (p == my_strategies.length) {
				//we've reset the last iterator, meaning we are finished.
				my_is_finished = true;
				
			} else {
				my_strategies[p].advance();
			}
		} catch (InstantiationException e) {
			// Already checked for exceptions in constructor. Should never be hit
			System.err.println(e);
		} catch (IllegalAccessException e) {
			System.err.println(e);
		}
  }
  // Constraints

  /**
   * {@inheritDoc}
   */
  @Override
  public boolean hasNext() {
    return my_iterator_wrapper.hasNext();
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public Object[] next() {
    return my_iterator_wrapper.next();
  }

  /**
   * Not implemented.
   * @throws UnsupportedOperationException Always thrown.
   */
  //@ signals (UnsupportedOperationException) true;
  @Override
  public void remove() throws UnsupportedOperationException {
    throw new UnsupportedOperationException();
  }

  // @constraint "The sequence of elements returned consists of arrays of
  // objects,
  // where each object is generated by using an iterator provided by
  // the iterator generation method in the corresponding position of
  // the list."

}
