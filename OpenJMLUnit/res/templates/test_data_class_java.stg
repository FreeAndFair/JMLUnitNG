group test_data_class_java : shared_java;

main(date, class, methods, types, packageName, packaged) ::= <<
/*
 * Test Data Class for <class.fullyQualifiedName>
 * Generated by JMLUnitNG on <date>
 */
 
<if (packaged)>
package <packageName>;
<endif>

import java.util.LinkedList;
import java.util.List;
import java.util.Iterator;

import org.jmlspecs.openjmlunit.iterator.IteratorAdapter;
import org.jmlspecs.openjmlunit.iterator.ObjectArrayIterator;
import org.jmlspecs.openjmlunit.iterator.ParameterArrayIterator;
import org.jmlspecs.openjmlunit.iterator.RepeatedAccessIterator;
import org.jmlspecs.openjmlunit.strategy.*;

import org.jmlspecs.jml4.rac.runtime.JMLAssertionError;

import org.testng.annotations.DataProvider;

<if (packaged)>
import <class.fullyQualifiedName>;
<endif>

/**
 * Data provider class generated by JMLUnitNG for class
 * <class.fullyQualifiedName>.
 * 
 * @author JMLUnitNG
 * @version <date>
 */
public class <dataClassName(class)> {
  <types:typeData(); separator="\n">
  <methods:methodData(); separator="\n">
  //---------------------------------------------------------------
  //End of user definitions
  //---------------------------------------------------------------
  /** Constructs the class object. */
  protected <dataClassName(class)>() {
  }
  <methods:methodProvider()>
  
  <if(!class.abstract)>
  <classOnlyDataProvider()>
  <classStrategy()>
  <endif>
}
>>

typeData() ::= <<
/**
 * For user definition. Supplies values of type <it.fullyQualifiedName> 
 * to be tested on each matching parameter.
 */
public static abstract class <globalStrategyName(typeName=it.formattedName)> extends <baseStrategyMap.(it.fullyQualifiedName)> {
  public RepeatedAccessIterator\<?\> getGlobalValues() {
    return new ObjectArrayIterator\<<typeTransMap.(it.fullyQualifiedName)>\>(new <typeTransMap.(it.fullyQualifiedName)>[] 
    { /* add global <it.fullyQualifiedName> values here */ });
  }
  <if(!it.primitive)>
  
  public <globalStrategyName(typeName=it.formattedName)>() {
    super(<it.fullyQualifiedName>.class);
  }
  <endif>
}

>>

methodData(method) ::= <<
<it.parameterTypes:paramData(the_method=method)>
>>

paramData(the_method) ::= <<
/**
 * For user definition. Supplies test values for:
 * Variable: <it.fullyQualifiedName> <it:varName()> 
 * Method: <the_method>
 */
public static class <strategyName(method=the_method, param=it)> extends <globalStrategyName(typeName=it.formattedName)> {
  public RepeatedAccessIterator\<?\> getCustomValues() {
  	return new ObjectArrayIterator\<<type(typeInfo=it)>\>(new <type(typeInfo=it)>[] 
  	{ /* add custom <it.fullyQualifiedName> values here */ });
  }
}

>>

methodProvider(method) ::= <<
<if(method.parameterTypes)>/**
 * Data provider for <if(method.constructor)>constructor<else>method<endif> <method>.
 * @return An iterator over strategies to use for parameter generation.
 */
@SuppressWarnings({"unchecked"})
@DataProvider(name = "<dataProviderName()>")
public static Iterator\<Object[]\> <dataProviderName()>() {
  return new ParameterArrayIterator(<if(!method.constructor)><classStrategyName()>.class, <endif><method.parameterTypes:{<strategyName(method=method, param=it)>.class}; wrap="\n    ", separator=", ">);
}
<endif>

>>

classOnlyDataProvider() ::= <<
/**
 * Data provider for methods with no parameters.
 * @return An iterator over the main class strategy.
 */
@SuppressWarnings({"unchecked"})
@DataProvider(name = "<classOnlyDataProviderName()>")
public static Iterator\<Object[]\> <classOnlyDataProviderName()>() {
  return new ParameterArrayIterator(<classStrategyName()>.class);
}

>>

classStrategy() ::= <<
/**
 * Utilizes constructor parameter data to define valid instances of <class.fullyQualifiedName> 
 * on which to call methods under test.
 */
public static class <classStrategyName()> extends ObjectStrategy {
  public RepeatedAccessIterator\<?\> getGlobalValues() {
    List\<<class.shortName>\> values = new LinkedList\<<class.shortName>\>();
    Object[] params;
    Iterator\<Object[]\> iter;
    <methods:{<classStrategyConstructorData(method=it)>}>
    return new IteratorAdapter\<<class.shortName>\>(values.iterator());
  }
  public RepeatedAccessIterator\<?\> getCustomValues() {
    return new ObjectArrayIterator\<<class.shortName>\>(new <class.shortName>[0]);
  }
  public RepeatedAccessIterator\<?\> getDefaultValues() {
    return new ObjectArrayIterator\<<class.shortName>\>(new <class.shortName>[0]);
  }
  public <classStrategyName()>() {
    super(<class.shortName>.class);
  }
}

>>

classStrategyConstructorData(method) ::= <<
<if(method.constructor)>
//objects for constructor <method>
<if(method.parameterTypes)>
iter = <dataProviderName()>();
while (iter.hasNext()) {
  params = iter.next();
  try {
    values.add(new <class.shortName>(<method.parameterTypes:{<cast(parameterType=it)> params[<i0>]}; wrap="\n      ", separator=", ">));
  } catch (final JMLAssertionError e) {
    // do nothing for JML failures in constructors
  } catch (final Exception e) {
    // do nothing for failed constructors
  }
}
<else>
try {
  values.add(new <class.shortName>());
} catch (final JMLAssertionError e) {
  // do nothing for JML failures in constructors
} catch (final Exception e) {
  // do nothing for failed constructors
}
<endif>
<endif>
>>

cast(parameterType) ::= "(<parameterType:type()>)"

strategyName(method, param) ::= "<param.parameterName>_<method.uniqueName>_Strategy"
classStrategyName() ::= "ClassObjectStrategy"
globalStrategyName(typeName) ::= "<it.formattedName>_GlobalStrategy"