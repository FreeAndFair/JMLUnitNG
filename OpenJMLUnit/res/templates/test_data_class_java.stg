group test_data_class_java : shared_java;

main(date, class, methods, types, packageName) ::= <<
// This class was generated by OpenJMLUnit on <date>
package <packageName>;

import java.util.Iterator;

import org.jmlspecs.openjmlunit.iterator.ObjectArrayIterator;
import org.jmlspecs.openjmlunit.iterator.ParameterArrayIterator;
import org.jmlspecs.openjmlunit.iterator.RepeatedAccessIterator;
import org.jmlspecs.openjmlunit.strategy.*;

import org.testng.annotations.DataProvider;

import <class.fullyQualifiedName>;

/**
 * This class is the data provider class generated by the OpenJMLUnit testing
 * framework for class <class.fullyQualifiedName>.
 * 
 * @version 1.0
 * @author OpenJMLUnit.
 */
public class <dataClassName(class)> {
  /** Constructs the class object. */
  public <dataClassName(class)>() {
  }

  /**
   * For user definition: Instances of <class.fullyQualifiedName> on which to call methods under test.
   */
  public static class <classStrategyName()> extends ObjectStrategy {
    public RepeatedAccessIterator\<?\> getGlobalValues() {
      return new ObjectArrayIterator\<<class.shortName>\>(new <class.shortName>[]
        { /* Add global values here */ });
    }
    public RepeatedAccessIterator\<?\> getCustomValues() {
      return new ObjectArrayIterator\<<class.shortName>\>(new <class.shortName>[0]);
    }
    public RepeatedAccessIterator\<?\> getDefaultValues() {
      return new ObjectArrayIterator\<<class.shortName>\>(new <class.shortName>[0]);
    }
    public <classStrategyName()>() {
      super(<class.shortName>.class);
    }
  }
  
  <types:typeData(); separator="\n">
  
  <methods:methodData(); separator="\n">
  
  //---------------------------------------------------------------
  //End of user definitions
  //---------------------------------------------------------------
  <methods:methodProvider()>
  
  <classOnlyDataProvider()>
}
>>

typeData() ::= <<
/**
 * For user definition: Values of type <it.fullyQualifiedName> to be tested on each matching parameter.
 */
public static abstract class <globalStrategyName(typeName=it.formattedName)> extends <baseStrategyMap.(it.fullyQualifiedName)> {
  public RepeatedAccessIterator\<?\> getGlobalValues() {
    return new ObjectArrayIterator\<<typeTransMap.(it.fullyQualifiedName)>\>(new <typeTransMap.(it.fullyQualifiedName)>[] 
     {/* Add global values here */});
  }
  <if(!it.primitive)>
  public <globalStrategyName(typeName=it.formattedName)>() {
    super(<it.fullyQualifiedName>.class);
  }
  <endif>
}
>>

methodData(method) ::= <<
<it.parameterTypes:paramData(methodName=method.name); separator="\n">
>>

paramData(methodName) ::= <<
/**
 * For user definition. Supplier of test values for:
 * Variable: <it:varName()> 
 * Method: <methodName>
 */
public static class <strategyName(methodNameStr=methodName, paramName=it:varName())> extends <globalStrategyName(typeName=it.formattedName)> {
  public RepeatedAccessIterator\<?\> getCustomValues() {
  	return new ObjectArrayIterator\<<typeTransMap.(it.fullyQualifiedName)>\>(new <typeTransMap.(it.fullyQualifiedName)>[] 
  	 {/* Add custom values here */});
  }
}
>>

methodProvider(method) ::= <<
<if(method.parameterTypes)>/**
 * Data provider for method <method.name>.
 * @return An iterator over strategies to use for parameter generation.
 */
@SuppressWarnings({"unchecked"})
@DataProvider(name = "<dataProviderName(name=method.name, params=method.parameterTypes)>")
public Iterator\<Object[]\> <dataProviderName(name=method.name, params=method.parameterTypes)>() {
  return new ParameterArrayIterator(<classStrategyName()>.class, <method.parameterTypes:{<strategyName(methodNameStr=method.name, paramName=it:varName())>.class}; wrap="\n    ", separator=", ">);
}
<endif>
>>

classOnlyDataProvider() ::= <<
/**
 * Data provider for methods with no parameters.
 * @return An iterator over the main class strategy.
 */
@SuppressWarnings({"unchecked"})
@DataProvider(name = "<classOnlyDataProviderName()>")
public Iterator\<Object[]\> <classOnlyDataProviderName()>() {
  return new ParameterArrayIterator(<classStrategyName()>.class);
}
>>

strategyName(methodNameStr, paramName) ::= "<methodNameStr>_<paramName>_Strategy"
classStrategyName() ::= "ClassObjectStrategy"
globalStrategyName(typeName) ::= "<it.formattedName>_GlobalStrategy"